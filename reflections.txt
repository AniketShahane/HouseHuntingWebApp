### This is a house hunt project that we are creating  ###

STEPS:

-------------------------------------------------------------------------------

1. The first Step is to get everything setup which we already know
-> git initialization, virtual environment setup and django installation

-------------------------------------------------------------------------------

2. What is the best place to store the templates ???
---> Inside the root directory ie. Where your manage.py resides
---> After this we go into settings.py of our project folder and define the path of all the templates
'''
  (inside templates list)
  DIRS: os.path.join(BASE_DIR, 'templates')
'''
*** This simply gives the path of the templates folder.. So whenever me make a render request django searches for that file inside of this templates folder....

-------------------------------------------------------------------------------

3. What is the best place to store the static files ???
---> Inside the main project folder ie. Where wsgi.py resides we create the static folder
---> After this we go into the settings.py of our main project
'''
STATIC_ROOT = os.join.path(BASE_DIR, 'static')
STATICFILES_DIRS = [
  os.join.path(BASE_DIR, 'HouseHunt/static')
]
STATIC_URL = '/static/'
'''
*** The static root just says that create a 'static' named folder in the base/root directory ie. where manage.py resides.
*** The static files just says that look into the 'Project_folder/static' folder for the files when we run '''python manage.py collectstatic'''
*** The static url just defines the url that the user should visit to look at these files
*** Wherever we want to use static files we need to write '''{% load static %}'''
*** To use the static files we need to write '''{% static 'file path inside of static' %}'''

-------------------------------------------------------------------------------

4. Now a good practice is the extend the elements like header and footer to other html files in out project so that we don't have to write the code again and again. But an even cleaner way of doing this is to make partials Eg. storing the code of the header in the folder templates/partials/_header.html
&&& storing the code of the footer in the folder templates/partials/_footer.html
--->
'''
(To include these partials into our base.html we just use this code)

{% include 'partials/_topbar.html' %}
{% include 'partials/_navbar.html' %}
{% include 'partials/_footer.html' %}
'''

-------------------------------------------------------------------------------

5. What does '''python manage.py makemigrations''' do ???
-> This command simply creates the files for the models so that when we further run the '''python manage.py migrate''' it will update the database to have the tables for our models.

-------------------------------------------------------------------------------

6. If we want to change the styling of the admin page of django
--> We first create an 'admin' folder inside the root templates directory and inside that we create a file 'base_site.html'
--> Inside that we have to first extend
'''
{% extends 'admin/base.html' %}
{% load static %}

{% block brading %}
  Change what we see on the top
{% endblock %}

{% block extrastyle %}
  Add links to css files... <link href="{% static 'css/admin.css' %} rel='stylesheet'" >
{% endblock %}
'''
---> To get the styling to appear the admin.css should be added inside the static folder of the main project and not the ***ROOT STATIC*** ie. where the wsgi.py is present.

-------------------------------------------------------------------------------

7. If We want to customize the way the admin page lists all the things in our database we can add things to the admin.py of that app
Eg. (inside the admin.py of the listings)
class ListingAdmin(admin.ModelAdmin):
  list_display = ('id', 'title', 'is_published', 'price', 'realtor')
  #shows the following field when we click on listings
  list_display_links = ('id', 'title')
  #shows the edit page when we click on either id or title before this it was just id b/c it was 1st
  list_filer = ('realtor',)
  #shows a filter which allows us to view the listings by realtor
  list_editable = ('is_published')
  #this will show a checkbox for is_published that doesn't require us to go into the edit page
  search_fields = ('title', 'description', 'address', 'city', 'state', 'price')
  #this allows us to search according to these fields
  list_perpage = 25
  #only shows 25 items on the page and creates the pagination

  def get_ordering(self, request):
    return ['id']
  #This sorts the entries in the ascending order wrt the id

-------------------------------------------------------------------------------

8. How to fetch the objects inside of our database ??
--> (inside of the views.py of the listings where we render the html page on request)
'''
from .models import Listing
(inside of the listings function)
listings = Listing.objects.all()
return render(request, 'listings/listings.html', {'listings':listings})
'''
---> To use these objects just loop through them

-------------------------------------------------------------------------------

9. We can also use django humanize (provides a whole lot of things)
-> To use this we just need to add 'django.contrib.humanize' to the installed apps section of settings
-> To use the functions inside of humanize we just need to load the humanize into the html of our site
-> {% load humanize %}
(to use this finally we just need a " | function_name")
Eg. 580000 | intcomma => 580,000
(COOL AF)

-------------------------------------------------------------------------------

10. We also need the paginator on the listings page to work. For this we use django paginator
-> To use the paginator we need to add the following code to the index function of listings' views.py
'''
def index(request):
    listings = Listing.objects.order_by('-list_date').filter(is_published=True)
    #Instead of all() we use 'order_by' to order the listings and filter so that only the ones that are published are viewed

    paginator = Paginator(listings, 6)
    #defines that there will be only 6 listings on every page
    page = request.GET.get('page')
    #gets the page object
    paged_listings = paginator.get_page(page)
    #gets the pages for the paginator so that we can view 6 listings on every page
    return render(request, 'listings/listings.html', {
    'listings': paged_listings
    })
'''
Q. But how do we implement this paginator into our HTML code ???
-->
'''
<div class="row">
  <div class="col-md-12">
    {% if listings.has_other_pages %}
    <ul class="pagination">
      {% if listings.has_previous %}
      <li class="page-item">
        <a href="?page={{listings.previous_page_number}}" class="page-link">&laquo;</a>
      </li>
      {% else %}
      <li class="page-item disabled">
        <a class="page-link">&laquo;</a>
      </li>
      {% endif %}
      {% for i in listings.paginator.page_range %}
      {% if listings.number == i %}
      <li class="page-item active">
        <a class="page-link">{{i}}</a>
      </li>
      {% else %}
      <li class="page-item">
        <a href="?page={{i}}" class="page-link">{{i}}</a>
      </li>
      {% endif %}
      {% endfor %}
      {% if listings.has_next %}
      <li class="page-item">
        <a href="?page={{listings.next_page_number}}" class="page-link">&raquo;</a>
      </li>
      {% else %}
      <li class="page-item disabled">
        <a class="page-link">&raquo;</a>
      </li>
      {% endif %}
    </ul>
    {% endif %}
  </div>
</div>

'''

-------------------------------------------------------------------------------
